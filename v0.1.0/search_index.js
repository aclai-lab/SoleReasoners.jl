var documenterSearchIndex = {"docs":
[{"location":"abstract-tableau/","page":"Abstract Tableau","title":"Abstract Tableau","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"abstract-tableau/","page":"Abstract Tableau","title":"Abstract Tableau","text":"Pages = [\"abstract-tableau.md\"]","category":"page"},{"location":"abstract-tableau/#man-core","page":"Abstract Tableau","title":"Abstract Tableau","text":"","category":"section"},{"location":"abstract-tableau/","page":"Abstract Tableau","title":"Abstract Tableau","text":"All tableaux structures are recursive structures resembling a tree structure. Each logic is associated with a specific tableau structure subtype of AbstractTableau, and must comprise at least a father, an array of children, and two flags expanded and closed.","category":"page"},{"location":"abstract-tableau/","page":"Abstract Tableau","title":"Abstract Tableau","text":"AbstractTableau\nfather(t::T) where {T<:AbstractTableau}\nchildren(t::T) where {T<:AbstractTableau}\nexpanded(t::T) where {T<:AbstractTableau}\nclosed(t::T) where {T<:AbstractTableau}\nisroot(t::T) where {T<:AbstractTableau}\nisleaf(t::T) where {T<:AbstractTableau}\nexpand!(t::T) where {T<:AbstractTableau}\nfindexpansionnode(t::T) where {T<:AbstractTableau}\nfindleaves(leaves::Vector{T}, t::T) where {T<:AbstractTableau}\nclose!(t::T) where {T<:AbstractTableau}\npushchild!(father::T, child::T) where {T<:AbstractTableau}\nBase.show(io::IO, _::T) where {T<:AbstractTableau}","category":"page"},{"location":"abstract-tableau/#SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.AbstractTableau","text":"abstract type AbstractTableau end\n\nAbstract type for all tableaux structures.\n\nAll tableaux structures are recursive structures resembling a tree structure. Each subtype T where T<:AbstractTableau is expected to have at least a field faher of the same type T (or Nothing in case it is the root), a field children comprising a vector of elements of type T, and two flags expanded and closed of type Bool claiming if the node has been expanded (resp. closed) or not.\n\n\n\n\n\n","category":"type"},{"location":"abstract-tableau/#SoleReasoners.father-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.father","text":"father(t::T) where {T<:AbstractTableau}\n\nReturn the father of a tableu t.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#SoleReasoners.children-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.children","text":"children(t::T) where {T<:AbstractTableau}\n\nReturn the vector of children of a tableu t.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#SoleReasoners.expanded-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.expanded","text":"expanded(t::T) where {T<:AbstractTableau}\n\nReturn true if a tableu t has already been expanded, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#SoleReasoners.closed-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.closed","text":"closed(t::T) where {T<:AbstractTableau}\n\nReturn true if a tableu t has already been closed, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#SoleReasoners.isroot-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.isroot","text":"isroot(t::T) where {T<:AbstractTableau}\n\nReturn true if a tableu t is the root of the tableau, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#SoleReasoners.isleaf-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.isleaf","text":"isleaf(t::T) where {T<:AbstractTableau}\n\nReturn true if a tableu t is a leaf of the tableau, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#SoleReasoners.expand!-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.expand!","text":"expand!(t::T) where {T<:AbstractTableau}\n\nSet the expanded flag to true.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#SoleReasoners.findexpansionnode-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.findexpansionnode","text":"findexpansionnode(t::T) where {T<:AbstractTableau}\n\nSearch for the node to be expanded recursevely scanning the ancestors of t.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#SoleReasoners.findleaves-Union{Tuple{T}, Tuple{Vector{T}, T}} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.findleaves","text":"findleaves(t::T) where {T<:AbstractTableau}\n\nFind all leaves descendants of t.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#SoleReasoners.close!-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.close!","text":"close!(t::T) where {T<:AbstractTableau}\n\nSet the closed flag of t to true and recursevely close all its descendants; if t is not the root of the tableau, also remove it from the list of children of its father and if t does not have any simblings recursevely close it.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#SoleReasoners.pushchild!-Union{Tuple{T}, Tuple{T, T}} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"SoleReasoners.pushchild!","text":"pushchild!(father::T, child::T) where {T<:AbstractTableau}\n\nPush new child tableau to the children of father tableau.\n\n\n\n\n\n","category":"method"},{"location":"abstract-tableau/#Base.show-Union{Tuple{T}, Tuple{IO, T}} where T<:SoleReasoners.AbstractTableau","page":"Abstract Tableau","title":"Base.show","text":"show(io::IO, _::T) where {T<:AbstractTableau}\n\nMethod to be overwritten with the signature of a specific tableaux structure.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Pages = [\"getting-started.md\"]","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleReasoners mainly provides two tools for reasoning: alphasat, which aims at solving the alpha-satisfiability problem, a relaxation of the boolean satisfiability problem for many-valued logic asking if an interpretation satisfies a formula with value at least alpha, and alphaval, which serves as an automated theorem prover solving the alpha-validity problem, a relaxation of the validity problem for many-valued logic asking if a formula is satisfied by any interpretation with value at least alpha. Both algorithms are based on the method of analytic tableaux.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleReasoners also provides a suite for managing the tableau expansion policy, allowing for different configurations based on the specific application problem. This system is based on min-heaps concurring to provide candidates for the extraction based on user specified policies, and an agreement function to choose amongst such proposals.","category":"page"},{"location":"getting-started/#SAT-solver","page":"Getting started","title":"SAT solver","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"alphasat(\n    ::T,\n    α::T1,\n    φ::Formula,\n    algebra::FiniteFLewAlgebra,\n    choosenode::Function,\n    metrics::Function...;\n    kwargs...\n) where {\n    T<:ManyValuedMultiModalTableau,\n    T1<:Truth\n}","category":"page"},{"location":"getting-started/#SoleReasoners.alphasat-Union{Tuple{T1}, Tuple{T}, Tuple{T, T1, SoleLogics.Formula, SoleLogics.ManyValuedLogics.FiniteFLewAlgebra, Function, Vararg{Function}}} where {T<:SoleReasoners.ManyValuedMultiModalTableau, T1<:SoleLogics.Truth}","page":"Getting started","title":"SoleReasoners.alphasat","text":"function alphasat(\n    ::T,\n    α::T1,\n    φ::Formula,\n    algebra::FiniteFLewAlgebra,\n    choosenode::Function,\n    metrics::Function...;\n    kwargs...\n) where {\n    T<:ManyValuedMultiModalTableau,\n    T1<:Truth\n}\n\nGiven a formula, return true if an interpretation that satisfies the formula with value at least α from a specified algebra exists, false otherwise.\n\nThe first argument should be a subtype of ManyValuedMultiModalTableau; currently supported tableaux are: MVLTLFPTableau, MVCLTableau, MVHSTableau and MVLRCC8Tableau.\n\nchoosenode should be a function taking a vector of metricheaps as an argument (and eventually a counter) and giving a tableau (or nothing) as output that is used to extract a node representing a branch to be expanded. If nothing, all branches are closed.\n\nmetrics should be functions taking a tableau as an argument and giving an integer as output that are used to model the order in which tableau branches are  xpanded. For example, one could declare the following metric functions:\n\nmf1(t::Tableau) = noperators(t.formula)\nmf2(t::Tableau) = height(t.formula)\n\nThe first metric will generate a metricheap proposing to expand first branches comprising the node containing the formula with the less number of operators, the second metric will generate a metricheap proposing to expand first branches comprising the node containing the formula of less height.\n\nchoosenode will then be used to choose which policy to follow (e.g., choosing the node voted by most heaps, or alternating between each heap at each cycle).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Automated-theorem-prover","page":"Getting started","title":"Automated theorem prover","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"alphaval(\n    ::T,\n    α::T1,\n    φ::Formula,\n    algebra::FiniteFLewAlgebra,\n    choosenode::Function,\n    metrics::Function...;\n    kwargs...\n) where {\n    T<:ManyValuedMultiModalTableau,\n    T1<:Truth\n}","category":"page"},{"location":"getting-started/#SoleReasoners.alphaval-Union{Tuple{T1}, Tuple{T}, Tuple{T, T1, SoleLogics.Formula, SoleLogics.ManyValuedLogics.FiniteFLewAlgebra, Function, Vararg{Function}}} where {T<:SoleReasoners.ManyValuedMultiModalTableau, T1<:SoleLogics.Truth}","page":"Getting started","title":"SoleReasoners.alphaval","text":"function alphaval(\n    ::T,\n    α::T1,\n    φ::Formula,\n    algebra::FiniteFLewAlgebra,\n    choosenode::Function,\n    metrics::Function...;\n    kwargs...\n) where {\n    T<:ManyValuedMultiModalTableau,\n    T1<:Truth\n}\n\nGiven a formula, return true if any possible interpretation satisfies the formula with value at least α from a specified algebra exists, false otherwise.\n\nThe first argument should be a subtype of ManyValuedMultiModalTableau; currently supported tableaux are: MVLTLFPTableau, MVCLTableau, MVHSTableau and MVLRCC8Tableau.\n\nchoosenode should be a function taking a vector of metricheaps as an argument (and eventually a counter) and giving a tableau (or nothing) as output that is used to extract a node representing a branch to be expanded. If nothing, all branches are closed.\n\nmetrics should be functions taking a tableau as an argument and giving an integer as output that are used to model the order in which tableau branches are  xpanded. For example, one could declare the following metric functions:\n\nmf1(t::Tableau) = noperators(t.formula)\nmf2(t::Tableau) = height(t.formula)\n\nThe first metric will generate a metricheap proposing to expand first branches comprising the node containing the formula with the less number of operators, the second metric will generate a metricheap proposing to expand first branches comprising the node containing the formula of less height.\n\nchoosenode will then be used to choose which policy to follow (e.g., choosing the node voted by most heaps, or alternating between each heap at each cycle).\n\n\n\n\n\n","category":"method"},{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]","category":"page"},{"location":"examples/#man-core","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"Pages = [\"many-valued-multi-modal-logic.md\"]","category":"page"},{"location":"many-valued-multi-modal-logic/#man-core","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"","category":"section"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"For all logics, many-valuedness is treated through FL_ew-algebras.","category":"page"},{"location":"many-valued-multi-modal-logic/#Many-Valued-Linear-Order","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Linear Order","text":"","category":"section"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"All logics are defined over a many-valued linear order.","category":"page"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"isaManyValuedLinearOrder(\n    mvlt::M,\n    mveq::M,\n    algebra::FiniteFLewAlgebra\n) where {\n    N,\n    M<:SMatrix{N,N,FiniteTruth}\n}\ncheckManyValuedLinearOrder(\n    mvlt::M,\n    mveq::M,\n    algebra::FiniteFLewAlgebra\n) where {\n    N,\n    M<:SMatrix{N,N,FiniteTruth}\n}\nManyValuedLinearOrder\ncardinality(o::ManyValuedLinearOrder)\nBase.show(io::IO, o::ManyValuedLinearOrder)","category":"page"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.isaManyValuedLinearOrder-Union{Tuple{M}, Tuple{N}, Tuple{M, M, SoleLogics.ManyValuedLogics.FiniteFLewAlgebra}} where {N, M<:(StaticArraysCore.SMatrix{N, N, SoleLogics.ManyValuedLogics.FiniteTruth})}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.isaManyValuedLinearOrder","text":"isaManyValuedLinearOrder(\n    mvlt::M,\n    mveq::M,\n    algebra::FiniteFLewAlgebra\n) where {\n    N,\n    M<:SMatrix{N,N,FiniteTruth}\n}\n\nReturn true if a domain of cardinality N enriched with two functions mveq and mvlt form a many-valued linear order, i.e., if the following axioms are satisfied:\n\ñ=(x,y) = ⊤ iff x = y\ñ=(x,y) = ̃=(y,x)\ñ<(x,x) = ⊥\ñ<(x,z) ⪰ ̃<(x,y) ⋅ ̃<(y,z)\nif ̃<(x,y) ≻ 0 and ̃<(y,z) ≻ 0 then ̃<(x,z) ≻ 0\nif ̃<(x,y) = 0 and ̃<(y,x) = 0 then ̃=(x,y) = 1\nif ̃=(x,y) ≻ 0 then ̃<(x,y) ≺ 1\n\nReturn false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.checkManyValuedLinearOrder-Union{Tuple{M}, Tuple{N}, Tuple{M, M, SoleLogics.ManyValuedLogics.FiniteFLewAlgebra}} where {N, M<:(StaticArraysCore.SMatrix{N, N, SoleLogics.ManyValuedLogics.FiniteTruth})}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.checkManyValuedLinearOrder","text":"checkManyValuedLinearOrder(\n    mvlt::M,\n    mveq::M,\n    algebra::FiniteFLewAlgebra\n) where {\n    N,\n    M<:SMatrix{N,N,FiniteTruth}\n}\n\nCheck if a domain of cardinality N enriched with two functions mveq and mvlt form a many-valued linear order, i.e., if the following axioms are satisfied:\n\ñ=(x,y) = ⊤ iff x = y\ñ=(x,y) = ̃=(y,x)\ñ<(x,x) = ⊥\ñ<(x,z) ⪰ ̃<(x,y) ⋅ ̃<(y,z)\nif ̃<(x,y) ≻ 0 and ̃<(y,z) ≻ 0 then ̃<(x,z) ≻ 0\nif ̃<(x,y) = 0 and ̃<(y,x) = 0 then ̃=(x,y) = 1\nif ̃=(x,y) ≻ 0 then ̃<(x,y) ≺ 1\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.ManyValuedLinearOrder","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.ManyValuedLinearOrder","text":"struct ManyValuedLinearOrder{N, M<:SMatrix{N,N,FiniteTruth}}\n    mvlt::M # ̃<\n    mveq::M # ̃=\n    algebra::FiniteFLewAlgebra\nend\n\nGiven an algebra, a many-valued linear order is a structure of the type (D,̃<,̃=) where D is a domain enriched with two functions ̃<, ̃=: D×D→A, for which the following conditions apply for every x, y and z in the domain D:\n\ñ=(x,y) = ⊤ iff x = y\ñ=(x,y) = ̃=(y,x)\ñ<(x,x) = ⊥\ñ<(x,z) ⪰ ̃<(x,y) ⋅ ̃<(y,z)\nif ̃<(x,y) ≻ 0 and ̃<(y,z) ≻ 0 then ̃<(x,z) ≻ 0\nif ̃<(x,y) = 0 and ̃<(y,x) = 0 then ̃=(x,y) = 1\nif ̃=(x,y) ≻ 0 then ̃<(x,y) ≺ 1\n\n\n\n\n\n","category":"type"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.cardinality-Tuple{SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.cardinality","text":"cardinality(o::ManyValuedLinearOrder)\n\nReturn the cardinality (i.e., number of Point1Ds), in the 'ManyValuedLinearOrder`.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#Base.show-Tuple{IO, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"Base.show","text":"show(io::IO, o::ManyValuedLinearOrder)\n\nA ManyValuedLinearOrder is printed with the tables for the many-valued functions ̃< and ̃= that represent it.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#Many-Valued-Multi-Modal-Logic","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"","category":"section"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"Each logic requires the definition of:","category":"page"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"a data structure representing a world in a specific logic\nthe many-valued evaluation functions for the relations in the logic","category":"page"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"One should notice how these structures change from the ones in SoleLogics.jl, as in the latter worlds need to carry a specific value that will be used for evaluation purposes (e.g., check and learning), hence they are not suited for reasoning tasks (e.g., frames should be dynamic).","category":"page"},{"location":"many-valued-multi-modal-logic/#Many-Valued-Linear-Temporal-Logic-with-Future-and-Past","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Linear Temporal Logic with Future and Past","text":"","category":"section"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"Point1D\nBase.show(io::IO, p::Point1D)\nmvlt(x1::Point1D, x2::Point1D, o::ManyValuedLinearOrder)\nmveq(x1::Point1D, x2::Point1D, o::ManyValuedLinearOrder)\nmvleq(x1::Point1D, x2::Point1D, o::ManyValuedLinearOrder)\nmveval(::typeof(LTLFP_F), x1::Point1D, x2::Point1D, o::ManyValuedLinearOrder)\nmveval(::typeof(LTLFP_P), x1::Point1D, x2::Point1D, o::ManyValuedLinearOrder)","category":"page"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.Point1D","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.Point1D","text":"struct Point1D\n    index::UInt8\nend\n\nA Point1D is represented by its index in a many-valued linear order domain.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-multi-modal-logic/#Base.show-Tuple{IO, SoleReasoners.Point1D}","page":"Many-Valued Multi-Modal Logic","title":"Base.show","text":"show(io::IO, p::Point1D)\n\nA Point1D is printed as xi, where i is its index in the domain associated with the many-valued linear order it belongs to.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mvlt-Tuple{SoleReasoners.Point1D, SoleReasoners.Point1D, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mvlt","text":"mvlt(x1::Point1D, x2::Point1D, o::ManyValuedLinearOrder)\n\nReturn the value for the ̃< function between two Point1Ds x1 and x2on the many-valued linear order o.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveq-Tuple{SoleReasoners.Point1D, SoleReasoners.Point1D, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveq","text":"mvlt(x1::Point1D, x2::Point1D, o::ManyValuedLinearOrder)\n\nReturn the value for the ̃= function between two Point1Ds x1 and x2on the many-valued linear order o.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mvleq-Tuple{SoleReasoners.Point1D, SoleReasoners.Point1D, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mvleq","text":"mvleq(x1::Point1D, x2::Point1D, o::ManyValuedLinearOrder)\n\nReturn the value for the ̃≤ function between two Point1Ds x1 and x2on the many-valued linear order o (i.e., ̃<(x1,x2) ∨ ̃=(x1,x2)).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._GreaterRel, SoleReasoners.Point1D, SoleReasoners.Point1D, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(LTLFP_F),\n    x1::Point1D,\n    x2::Point1D,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function x1Rx2 = ̃<(x1,x2) for relation R=LTLFP_F in many-valued linear order o (how much x2 is in the future w.r.t. x1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._LesserRel, SoleReasoners.Point1D, SoleReasoners.Point1D, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(LTLFP_P),\n    x1::Point1D,\n    x2::Point1D,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function x1Rx2 = ̃<(x2,x1) for relation R=LTLFP_P in many-valued linear order o (how much x2 is in the past w.r.t. x1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#Many-Valued-Compass-Logic","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Compass Logic","text":"","category":"section"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"Point2D\nBase.show(io::IO, p::Point2D)\nmveval(\n    ::typeof(CL_N),\n    p1::Point2D,\n    p2::Point2D,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\nmveval(\n    ::typeof(CL_S),\n    p1::Point2D,\n    p2::Point2D,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\nmveval(\n    ::typeof(CL_E),\n    p1::Point2D,\n    p2::Point2D,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\nmveval(\n    ::typeof(CL_W),\n    p1::Point2D,\n    p2::Point2D,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)","category":"page"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.Point2D","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.Point2D","text":"struct Point2D\n    px::Point1D\n    py::Point1D\nend\n\nA Point2D is represented by a Point1D in a many-valued linear order Dx and another Point1D in a many-valued linear order Dy.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-multi-modal-logic/#Base.show-Tuple{IO, SoleReasoners.Point2D}","page":"Many-Valued Multi-Modal Logic","title":"Base.show","text":"show(io::IO, p::Point2D)\n\nA Point2D is printed as (xi,yj), where i is the index of the Point1D in the domain associated with the many-valued linear order Dx, and j is the index of the Point1D in the domain associated with the many-valued linear order Dy.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._CL_N, SoleReasoners.Point2D, SoleReasoners.Point2D, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(CL_N),\n    p1::Point2D,\n    p2::Point2D,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function p1Rp2 = ̃=(p1x,p2x)⋅̃<(p1y,p2y) for relation R=CL_N in many-valued linear orders ox and oy (how much p2 is norther than p1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._CL_S, SoleReasoners.Point2D, SoleReasoners.Point2D, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(CL_S),\n    p1::Point2D,\n    p2::Point2D,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function p1Rp2 = ̃=(p1x,p2x)⋅̃<(p2y,p1y) for relation R=CL_S in many-valued linear orders ox and oy (how much p2 is souther than p1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._CL_E, SoleReasoners.Point2D, SoleReasoners.Point2D, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(CL_E),\n    p1::Point2D,\n    p2::Point2D,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function p1Rp2 = ̃<(p1x,p2x)⋅̃=(p1y,p2y) for relation R=CL_E in many-valued linear orders ox and oy (how much p2 is easter than p1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._CL_W, SoleReasoners.Point2D, SoleReasoners.Point2D, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(CL_W),\n    p1::Point2D,\n    p2::Point2D,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function p1Rp2 = ̃<(p2x,p1x)⋅̃=(p1y,p2y) for relation R=CL_W in many-valued linear orders ox and oy (how much p2 is wester than p1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#Many-Valued-Halpern-and-Shoham's-modal-logic-of-time-intervals","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Halpern and Shoham's modal logic of time intervals","text":"","category":"section"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"isaInterval(p1::Point1D, p2::Point1D, o::ManyValuedLinearOrder)\ncheckInterval(p1::Point1D, p2::Point1D, o::ManyValuedLinearOrder)\nInterval\nBase.show(io::IO, i::Interval)\nmveval(\n    ::typeof(HS_A),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_L),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_B),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_E),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_D),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_O),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_Ai),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_Li),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_Bi),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_Ei),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_Di),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\nmveval(\n    ::typeof(HS_Oi),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)","category":"page"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.isaInterval-Tuple{SoleReasoners.Point1D, SoleReasoners.Point1D, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.isaInterval","text":"isaInterval(p1::Point1D, p2::Point1D, o::ManyValuedLinearOrder)\n\nReturn true if a two Point1Ds p1 and p1 form an interval in the many-valued linear order o, i.e., ̃<(p1,p2) ≻ ⊥; return false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.checkInterval-Tuple{SoleReasoners.Point1D, SoleReasoners.Point1D, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.checkInterval","text":"checkInterval(p1::Point1D, p2::Point1D, o::ManyValuedLinearOrder)\n\nCheck if a two Point1Ds p1 and p1 form an interval in the many-valued linear order o, i.e., ̃<(p1,p2) ≻ ⊥. \n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.Interval","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.Interval","text":"struct Interval\n    p1::Point1D\n    p1::Point1D\nend\n\nAn Interval is represented by two Point1Ds in the same many-valued linear order.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-multi-modal-logic/#Base.show-Tuple{IO, SoleReasoners.Interval}","page":"Many-Valued Multi-Modal Logic","title":"Base.show","text":"show(io::IO, p::Interval)\n\nAn Interval is printed as [xi,xj], where i and j are the indexes of the Point1Ds p1 and p2 in the domain associated with the many-valued linear order they belong to.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_A, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_A),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃=(i1p2,i2p1) for relation R=HS_A in many-valued linear order o (how much i2 is after i1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_L, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_L),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃<(i1p2,i2p1) for relation R=HS_L in many-valued linear order o (how much i2 is later than i1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_B, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_B),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃=(i1p1,i2p1) ⋅ ̃<(i2p2,i1p2) for relation R=HS_B in many-valued linear order o (how much i2 is at the begin of i1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_E, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_E),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃<(i1p1,i2p1) ⋅ ̃=(i1p2,i2p2) for relation R=HS_E in many-valued linear order o (how much i2 is at the end of i1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_D, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_D),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃<(i1p1,i2p1) ⋅ ̃<(i2p2,i1p2) for relation R=HS_D in many-valued linear order o (how much i2 is during i1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_O, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_O),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃<(i1p1,i2p1) ⋅ ̃<(i2p1,i1p2) ⋅ ̃<(i1p2, i2p2) for relation R=HS_O in many-valued linear order o (how much i2 is overlapping i1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_Ai, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_Ai),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃=(i2p2,i1p1) for relation R=HS_Ai in many-valued linear order o (how much i1 is after i2).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_Li, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_Li),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃<(i2p2,i1p1) for relation R=HS_Li in many-valued linear order o (how much i1 is later than i2).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_Bi, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_Bi),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃=(i1p1,i2p1) ⋅ ̃<(i1p2,i2p2) for relation R=HS_Bi in many-valued linear order o (how much i1 is at the begin of i2).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_Ei, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_Ei),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃<(i2p1,i1p1) ⋅ ̃=(i1p2,i2p2) for relation R=HS_Ei in many-valued linear order o (how much i1 is at the end of i2).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_Di, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_Di),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃<(i2p1,i1p1) ⋅ ̃<(i1p2,i2p2) for relation R=HS_Di in many-valued linear order o (how much i1 is during i2).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._IA_Oi, SoleReasoners.Interval, SoleReasoners.Interval, SoleReasoners.ManyValuedLinearOrder}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(HS_Oi),\n    i1::Interval,\n    i2::Interval,\n    o::ManyValuedLinearOrder\n)\n\nMany-valued evaluation function i1Ri2 = ̃<(i2p1,i1p1) ⋅ ̃<(i1p1,i2p2) ⋅ ̃<(i2p2, i1p2) for relation R=HS_Oi in many-valued linear order o (how much i1 is overlapping i2).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#Many-Valued-Lutz-and-Wolter's-modal-logic-of-topological-relations-with-rectangular-areas-aligned-with-the-axes","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Lutz and Wolter's modal logic of topological relations with rectangular areas aligned with the axes","text":"","category":"section"},{"location":"many-valued-multi-modal-logic/","page":"Many-Valued Multi-Modal Logic","title":"Many-Valued Multi-Modal Logic","text":"Rectangle\nBase.show(io::IO, r::Rectangle)\nmveval(\n    ::typeof(LRCC8_Rec_DC),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\nmveval(\n    ::typeof(LRCC8_Rec_EC),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\nmveval(\n    ::typeof(LRCC8_Rec_PO),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\nmveval(\n    ::typeof(LRCC8_Rec_TPP),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\nmveval(\n    ::typeof(LRCC8_Rec_NTPP),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\nmveval(\n    ::typeof(LRCC8_Rec_TPPi),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\nmveval(\n    ::typeof(LRCC8_Rec_NTPPi),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)","category":"page"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.Rectangle","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.Rectangle","text":"struct Rectangle\n    ix::Interval\n    iy::Interval\nend\n\nA Rectangle is represented by an Interval on a many-valued linear order Dx and another Interval on a many-valued linear order Dy.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-multi-modal-logic/#Base.show-Tuple{IO, SoleReasoners.Rectangle}","page":"Many-Valued Multi-Modal Logic","title":"Base.show","text":"A Rectangle is printed as ([xi,xj],[yk,yl]), where i and j are the indexes of the Point1Ds of the first Interval in the domain associated with the many-valued linear order Dx and k and l are the indexes of the Point1Ds of the second Interval in the domain associated with the many-valued linear order Dy.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._Topo_DC, SoleReasoners.Rectangle, SoleReasoners.Rectangle, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(LRCC8_Rec_DC),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function r1Rr2 for relation R=LRCC8RecDC in many-valued linear orders ox and oy (how much r2 is disconnected from r1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._Topo_EC, SoleReasoners.Rectangle, SoleReasoners.Rectangle, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(LRCC8_Rec_EC),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function r1Rr2 for relation R=LRCC8RecEC in many-valued linear orders ox and oy (how much r2 is externally connected with r1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._Topo_PO, SoleReasoners.Rectangle, SoleReasoners.Rectangle, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(LRCC8_Rec_PO),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function r1Rr2 for relation R=LRCC8RecPO in many-valued linear orders ox and oy (how much r2 is partially overlapping with r1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._Topo_TPP, SoleReasoners.Rectangle, SoleReasoners.Rectangle, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(LRCC8_Rec_TPP),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function r1Rr2 for relation R=LRCC8RecTPP in many-valued linear orders ox and oy (how much r2 is a tangential proper part of r1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._Topo_NTPP, SoleReasoners.Rectangle, SoleReasoners.Rectangle, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(LRCC8_Rec_NTPP),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function r1Rr2 for relation R=LRCC8RecNTPP in many-valued linear orders ox and oy (how much r2 is a non-tangential proper part of r1).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._Topo_TPPi, SoleReasoners.Rectangle, SoleReasoners.Rectangle, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(LRCC8_Rec_TPPi),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function r1Rr2 for relation R=LRCC8RecTPPi in many-valued linear orders ox and oy (how much r1 is a tangential proper part of r2).\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-logic/#SoleReasoners.mveval-Tuple{SoleLogics._Topo_NTPPi, SoleReasoners.Rectangle, SoleReasoners.Rectangle, Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}}","page":"Many-Valued Multi-Modal Logic","title":"SoleReasoners.mveval","text":"function mveval(\n    ::typeof(LRCC8_Rec_NTPPi),\n    r1::Rectangle,\n    r2::Rectangle,\n    (ox,oy)::NTuple{2,ManyValuedLinearOrder}\n)\n\nMany-valued evaluation function r1Rr2 for relation R=LRCC8RecNTPPi in many-valued linear orders ox and oy (how much r1 is a non-tangential proper part of r2).\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"Pages = [\"metric-heap.md\"]","category":"page"},{"location":"metric-heap/#man-core","page":"Metric Heap","title":"Metric Heap","text":"","category":"section"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"The necessary components for the search strategies allowing for a ``smarter'' way of expanding the tableau tree structure, aiming at finding a fully expanded open branch (resp. closing all branches) in the fastest way possible.","category":"page"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"A MetricHeap is basically a heap parametrized over a metric, i.e., a function which extracts some information about a tableau branch, therefore containing in each node a tableau branch and the relative value for the metric, and which is  ordered as a min heap over this metric value.","category":"page"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"Note that all MetricHeaps are ordered from the smaller value to the greatest, and can contain negative values (all Ints)","category":"page"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"Helpers to clear the heaps (e.g., to deallocate memory removing already expanded non-leaf nodes and closed nodes) are also provided.","category":"page"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"MetricHeapNode{T<:AbstractTableau}\nmetricvalue(metricheapnode::MetricHeapNode)\ntableau(metricheapnode::MetricHeapNode)\nBase.show(io::IO, metricheapnode::MetricHeapNode)\nMetricHeapOrdering\nlt(_::MetricHeapOrdering, a::MetricHeapNode, b::MetricHeapNode)\nMetricHeap\nheap(metricheap::MetricHeap)\nmetric(metricheap::MetricHeap)\npush!(metricheap::MetricHeap, metricheapnode::MetricHeapNode)\npush!(metricheap::MetricHeap, tableau::T) where {T<:AbstractTableau}\npush!(\n    metricheaps::Vector{MetricHeap},\n    tableau::T\n) where {\n    T<:AbstractTableau\n}\npop!(metricheap::MetricHeap)\nisempty(metricheap::MetricHeap)\ncleanheap!(metricheap::MetricHeap)\ncleanheaps!(metricheaps::Vector{MetricHeap})\nBase.show(io::IO, metricheap::MetricHeap)","category":"page"},{"location":"metric-heap/#SoleReasoners.MetricHeapNode","page":"Metric Heap","title":"SoleReasoners.MetricHeapNode","text":"struct MetricHeapNode{T<:AbstractTableau}\n    metricvalue::Int\n    tableau::T\nend\n\nThe atomic element of a MetricHeap, it contains a tableau branch and a value for the metric associated with the MetricHeap it is contained in.\n\n\n\n\n\n","category":"type"},{"location":"metric-heap/#SoleReasoners.metricvalue-Tuple{SoleReasoners.MetricHeapNode}","page":"Metric Heap","title":"SoleReasoners.metricvalue","text":"metricvalue(metricheapnode::MetricHeapNode)\n\nGetter for the metric value of a heap node.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#SoleReasoners.tableau-Tuple{SoleReasoners.MetricHeapNode}","page":"Metric Heap","title":"SoleReasoners.tableau","text":"tableau(metricheapnode::MetricHeapNode)\n\nGetter for the tableau branch of a heap node.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#Base.show-Tuple{IO, SoleReasoners.MetricHeapNode}","page":"Metric Heap","title":"Base.show","text":"Base.show(io::IO, metricheapnode::MetricHeapNode)\n\nA MetricHeapNode is represented as a tuple (metricvalue, tableau).\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#SoleReasoners.MetricHeapOrdering","page":"Metric Heap","title":"SoleReasoners.MetricHeapOrdering","text":"struct MetricHeapOrdering <: Base.Order.Ordering end\n\nDefinition of a new ordering for the heaps treating them as min heaps ordered on the metric value.\n\n\n\n\n\n","category":"type"},{"location":"metric-heap/#Base.Order.lt-Tuple{SoleReasoners.MetricHeapOrdering, SoleReasoners.MetricHeapNode, SoleReasoners.MetricHeapNode}","page":"Metric Heap","title":"Base.Order.lt","text":"lt(_::MetricHeapOrdering, a::MetricHeapNode, b::MetricHeapNode)\n\nDefinition of the lt function for the new ordering.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#SoleReasoners.MetricHeap","page":"Metric Heap","title":"SoleReasoners.MetricHeap","text":"struct MetricHeap\n    heap::BinaryHeap{MetricHeapNode}\n    metric::Function\nend\n\nA MetricHeap is basically a heap parametrized over a metric, i.e., a function which extracts some information about a tableau branch, therefore containing in each node a tableau branch and the relative value for the metric, and which is  ordered as a min heap over this metric value.\n\nNote that all MetricHeaps are ordered from the smaller value to the greatest, and can contain negative values (all Ints).\n\n\n\n\n\n","category":"type"},{"location":"metric-heap/#SoleReasoners.heap-Tuple{SoleReasoners.MetricHeap}","page":"Metric Heap","title":"SoleReasoners.heap","text":"heap(metricheap::MetricHeap)\n\nGetter for the binary heap of a MetricHeap.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#SoleReasoners.metric-Tuple{SoleReasoners.MetricHeap}","page":"Metric Heap","title":"SoleReasoners.metric","text":"metric(metricheap::MetricHeap)\n\nGetter for the metric function of a MetricHeap.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#Base.push!-Tuple{SoleReasoners.MetricHeap, SoleReasoners.MetricHeapNode}","page":"Metric Heap","title":"Base.push!","text":"push!(metricheap::MetricHeap, metricheapnode::MetricHeapNode)\n\nPush new metricheapnode to a MetricHeap.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#Base.push!-Union{Tuple{T}, Tuple{SoleReasoners.MetricHeap, T}} where T<:SoleReasoners.AbstractTableau","page":"Metric Heap","title":"Base.push!","text":"push!(metricheap::MetricHeap, tableau::T) where {T<:AbstractTableau}\n\nPush new tableau to a MetricHeap.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#Base.push!-Union{Tuple{T}, Tuple{Vector{SoleReasoners.MetricHeap}, T}} where T<:SoleReasoners.AbstractTableau","page":"Metric Heap","title":"Base.push!","text":"push!(\n    metricheaps::Vector{MetricHeap},\n    tableau::T\n) where {\n    T<:AbstractTableau\n}\n\nPush new tableau to each metric heap.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#Base.pop!-Tuple{SoleReasoners.MetricHeap}","page":"Metric Heap","title":"Base.pop!","text":"pop!(metricheap::MetricHeap)\n\nPop head of a MetricHeap and return the tableau associated with it.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#Base.isempty-Tuple{SoleReasoners.MetricHeap}","page":"Metric Heap","title":"Base.isempty","text":"isempty(metricheap::MetricHeap)\n\nReturns true if the MetricHeap is empty, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#SoleReasoners.cleanheap!-Tuple{SoleReasoners.MetricHeap}","page":"Metric Heap","title":"SoleReasoners.cleanheap!","text":"cleanheaps!(metricheaps::Vector{MetricHeap})\n\nFunction to clean the MetricHeap removing all the nodes that have already been expanded that are not leaves (as the latters correspond to an open fully expanded branch, i.e., a satisfiable branch) or closed.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#SoleReasoners.cleanheaps!-Tuple{Vector{SoleReasoners.MetricHeap}}","page":"Metric Heap","title":"SoleReasoners.cleanheaps!","text":"cleanheaps!(metricheaps::Vector{MetricHeap})\n\nFunction to clean the MetricHeaps removing from all heaps all the nodes that have already been expanded that are not leaves (as the latters correspond to an open fully expanded branch, i.e., a satisfiable branch) or closed.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#Base.show-Tuple{IO, SoleReasoners.MetricHeap}","page":"Metric Heap","title":"Base.show","text":"Base.show(io::IO, metricheap::MetricHeap)\n\nA MetricHeap is represented by its metric and its heap.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#Metrics","page":"Metric Heap","title":"Metrics","text":"","category":"section"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"Various metrics that can be used to create MetricHeaps to ease the search of the expansion node on any tableau, such as randombranch assigning a random weight to each node when pushing it into the heaps, distancefromroot assignign to each node its distance from the root giving priority to smaller distances (i.e., breadth-first search), or inversedistancefromroot, giving priority to larger distances (i.e., a sort of depth-first search).","category":"page"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"metrics using specific fields of tableaux structures (e.g., formula for formulalength for PropositionalTableau) can be found in the metric.jl file of each subdirectory.","category":"page"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"randombranch(_::T) where {T<:AbstractTableau}\ndistancefromroot(t::T) where {T<:AbstractTableau}\ninversedistancefromroot(t::T) where {T<:AbstractTableau}\nformulaheight(t::T) where {T<:ManyValuedMultiModalTableau}","category":"page"},{"location":"metric-heap/#SoleReasoners.randombranch-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Metric Heap","title":"SoleReasoners.randombranch","text":"randombranch(_::T) where {T<:AbstractTableau}\n\nmetric assigning a random weight to each node when pushing it into the heaps. It leverages Xoshiro as pseudo-random generator with random seed.\n\nFor deterministic execution (i.e., experimental environments), it is advised to reimplement a similar custom function specifying a seed for the generator, such as:     rng = Xoshiro(42)     customrandombranch(_::T) where {T<:AbstractTableau} = rand(rng, Int) Note that the rng is defined outside of the function body; otherwise, it produces always the same value.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#SoleReasoners.distancefromroot-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Metric Heap","title":"SoleReasoners.distancefromroot","text":"distancefromroot(t::T) where {T<:AbstractTableau}\n\nmetric assignign to each node its distance from the root giving priority to smaller distances (somewhat similar to breadth-first search).\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#SoleReasoners.inversedistancefromroot-Tuple{T} where T<:SoleReasoners.AbstractTableau","page":"Metric Heap","title":"SoleReasoners.inversedistancefromroot","text":"inversedistancefromroot(t::T) where {T<:AbstractTableau}\n\nmetric assignign to each node its distance from the root giving priority to larger distances (somewhat similar to deep-first search).\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#SoleReasoners.formulaheight-Tuple{T} where T<:SoleReasoners.ManyValuedMultiModalTableau","page":"Metric Heap","title":"SoleReasoners.formulaheight","text":"formulaheight(t::T) where {T<:ManyValuedMultiModalTableau}\n\nmetric assignign to each node the height of its formula in the assertion, or 0 in case the assertion is of the type {<:Truth,<:Truth}.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#Choosenode","page":"Metric Heap","title":"Choosenode","text":"","category":"section"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"Various policies to choose which node to actually expand given the heads of the heaps (i.e., using a roundrobin! policy, choosing each time the head of a different heap in a sequential way, or mostvoted!, choosing the node that is the head of most heaps).","category":"page"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"Note that all policies are are signed as !, as they change the structures (``popping'' elements from the heaps).","category":"page"},{"location":"metric-heap/","page":"Metric Heap","title":"Metric Heap","text":"roundrobin!(metricheaps::Vector{MetricHeap}, cycle::Int)\nmostvoted!(metricheaps::Vector{MetricHeap}, args...)","category":"page"},{"location":"metric-heap/#SoleReasoners.roundrobin!-Tuple{Vector{SoleReasoners.MetricHeap}, Int64}","page":"Metric Heap","title":"SoleReasoners.roundrobin!","text":"roundrobin!(metricheaps::Vector{MetricHeap}, cycle::Int)\n\nChoose a node using the provided MetricHeaps, alternating between them at each cycle.\n\nThe result can either be nothing, in case all heaps are empty and therefore the tableau closed, or a node; an expanded node can only be returned if it is a leaf and in that case it represents a satisfiable branch for the tableau (i.e., a fully expanded open branch without contraddictions).\n\nThis is the default and suggested policy, as it prevents starvation.\n\n\n\n\n\n","category":"method"},{"location":"metric-heap/#SoleReasoners.mostvoted!-Tuple{Vector{SoleReasoners.MetricHeap}, Vararg{Any}}","page":"Metric Heap","title":"SoleReasoners.mostvoted!","text":"mostvoted!(metricheaps::Vector{MetricHeap}, args...)\n\nChoose a leaf using the provided MetricHeaps, returning the leaf which is the head of most of the heaps. In case\n\nTo prevent starvation, use roundrobin! instead.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"#SoleReasoners","page":"Home","title":"SoleReasoners","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleReasoners, a Julia package for automated reasoning up to Many-Valued Multi-Modal Logic built on top of SoleLogics and part of Sole.jl, an open-source framework for symbolic machine learning.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SoleReasoners.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SoleReasoners\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleReasoners.jl provides a SAT solver and an automated theorem prover up to Many-Valued Multi-Modal Logic based on the method of analytic tableau.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"#More-on-Sole","page":"Home","title":"More on Sole","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleLogics\nSoleData.jl\nSoleModels.jl\nSolePostHoc.jl","category":"page"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"Pages = [\"many-valued-multi-modal-tableau.md\"]","category":"page"},{"location":"many-valued-multi-modal-tableau/#man-core","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"","category":"section"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"The necessary components to reason about many-valued multi-modal logic using an Analytic Tableaux Technique, suitable for both alpha-satisfiability and alpha-validity, i.e., the counterparts of classical (crisp) satisfiability and authomated theorem proving, asking that the evaluation of a formula varphi has value at least alpha for one  possible model in one possible world (resp, all possible models in all possible worlds). Classical satisfiability and validity are obtained setting alpha=1.","category":"page"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"ManyValuedMultiModalTableau\njudgement(t::T) where {T<:ManyValuedMultiModalTableau}\nassertion(t::T) where {T<:ManyValuedMultiModalTableau}\nworld(t::T) where {T<:ManyValuedMultiModalTableau}\nframe(t::T) where {T<:ManyValuedMultiModalTableau}\nworlds(\n    ::Type{T},\n    frame::Union{ManyValuedLinearOrder, NTuple{2, ManyValuedLinearOrder}}\n) where {\n    T<:ManyValuedMultiModalTableau\n}\nnewframes(\n    t::T,\n    algebra::FiniteFLewAlgebra\n) where {\n    T<:ManyValuedMultiModalTableau\n}\nBase.show(io::IO, t::T) where {T<:ManyValuedMultiModalTableau}","category":"page"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.ManyValuedMultiModalTableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.ManyValuedMultiModalTableau","text":"abstract type ManyValuedMultiModalTableau <: AbstractTableau end\n\nTableau to reason about Many-Valued Multi-Modal Logic; a subtype of ManyValuedMultiModalTableau is expected to have at least a judgement, an assertion, a world, a frame, a father, an array of children, and two flags expanded and closed.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.judgement-Tuple{T} where T<:SoleReasoners.ManyValuedMultiModalTableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.judgement","text":"judgement(t::T) where {T<:ManyValuedMultiModalTableau}\n\nReturn the judgement (either true or false) associated with the tableu t.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.assertion-Tuple{T} where T<:SoleReasoners.ManyValuedMultiModalTableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.assertion","text":"assertion(t::T) where {T<:ManyValuedMultiModalTableau}\n\nReturn the assertion associated with a tableu t.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.world-Tuple{T} where T<:SoleReasoners.ManyValuedMultiModalTableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.world","text":"world(t::T) where {T<:ManyValuedMultiModalTableau}\n\nReturn the world associated with a tableu t.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.frame-Tuple{T} where T<:SoleReasoners.ManyValuedMultiModalTableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.frame","text":"frame(t::T) where {T<:ManyValuedMultiModalTableau}\n\nReturn the frame associated with a tableu t.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.worlds-Union{Tuple{T}, Tuple{Type{T}, Union{Tuple{SoleReasoners.ManyValuedLinearOrder, SoleReasoners.ManyValuedLinearOrder}, SoleReasoners.ManyValuedLinearOrder}}} where T<:SoleReasoners.ManyValuedMultiModalTableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.worlds","text":"worlds(\n    ::Type{T},\n    frame::Union{ManyValuedLinearOrder, NTuple{2, ManyValuedLinearOrder}}\n) where {\n    T<:ManyValuedMultiModalTableau\n}\n\nReturn all the worlds in the frame associated with a tableau t.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.newframes-Union{Tuple{T}, Tuple{T, SoleLogics.ManyValuedLogics.FiniteFLewAlgebra}} where T<:SoleReasoners.ManyValuedMultiModalTableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.newframes","text":"newframes(\n::Type{T},\nalgebra::FiniteFLewAlgebra\n\n) where {     T<:ManyValuedMultiModalTableau }\n\nReturn all the new possible frames for a tableau of type T.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-tableau/#Base.show-Union{Tuple{T}, Tuple{IO, T}} where T<:SoleReasoners.ManyValuedMultiModalTableau","page":"Many-Valued Multi-Modal Tableau","title":"Base.show","text":"show(io::IO, t::T) where {T<:ManyValuedMultiModalTableau}\n\nA ManyValuedMultiModalTableau is printed as a decoration Q(α⪯φ,w,F) or Q(φ⪯α,w,F) where Q is a judgement, α⪯φ and φ⪯α are assertions on a world w, and F is a frame represented by either a ManyValuedLinearOrder or a tuple of two ManyValuedLinearOrders.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"Each many-valued multi-modal logic is associated with a specific tableau structure subtype of ManyValuedMultiModalTableau, and must comprise a judgement, an assertion, a world, a frame, a father, an array of children, and two flags expanded and closed.","category":"page"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"Different subtypes of ManyValuedMultiModalTableau usually differ for the type of world and frame, which can be either a ManyValuedLinearOrder or an NTuple{N,ManyValuedLinearOrder}, as well as the recursive fields (i.e.,  father and children), sharing the same subtype of  ManyValuedMultiModalTableau.","category":"page"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"All structures will be digested by the same algorithms, parameterized on the subtype of ManyValuedMultiModalTableau.","category":"page"},{"location":"many-valued-multi-modal-tableau/#A-tableau-for-Many-Valued-Linear-Temporal-Logic-with-Future-and-Past","page":"Many-Valued Multi-Modal Tableau","title":"A tableau for Many-Valued Linear Temporal Logic with Future and Past","text":"","category":"section"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"MVLTLFPTableau","category":"page"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.MVLTLFPTableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.MVLTLFPTableau","text":"mutable struct MVLTLFPTableau <: ManyValuedMultiModalTableau\n    const judgement::Bool\n    const assertion::NTuple{2,Formula}\n    const world::Point1D\n    const frame::ManyValuedLinearOrder\n    const father::Union{MVLTLFPTableau,Nothing}\n    const children::Vector{MVLTLFPTableau}\n    expanded::Bool\n    closed::Bool\nend\n\nTableau to reason about Many-Valued Linear Temporal Logic with Future and Past.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-multi-modal-tableau/#A-tableau-for-Many-Valued-Compass-Logic","page":"Many-Valued Multi-Modal Tableau","title":"A tableau for Many-Valued Compass Logic","text":"","category":"section"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"MVCLTableau","category":"page"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.MVCLTableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.MVCLTableau","text":"mutable struct MVCLTableau <: ManyValuedMultiModalTableau\n    const judgement::Bool\n    const assertion::NTuple{2,Formula}\n    const world::Point2D\n    const frame::NTuple{2,ManyValuedLinearOrder}\n    const father::Union{MVCLTableau,Nothing}\n    const children::Vector{MVCLTableau}\n    expanded::Bool\n    closed::Bool\nend\n\nTableau to reason about Many-Valued Compass Logic.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-multi-modal-tableau/#A-tableau-for-Many-Valued-Halpern-and-Shoham's-modal-logic-of-time","page":"Many-Valued Multi-Modal Tableau","title":"A tableau for Many-Valued Halpern and Shoham's modal logic of time","text":"","category":"section"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"MVHSTableau","category":"page"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.MVHSTableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.MVHSTableau","text":"mutable struct MVHSTableau <: ManyValuedMultiModalTableau\n    const judgement::Bool\n    const assertion::NTuple{2,Formula}\n    const world::Interval\n    const frame::ManyValuedLinearOrder\n    const father::Union{MVHSTableau,Nothing}\n    const children::Vector{MVHSTableau}\n    expanded::Bool\n    closed::Bool\nend\n\nTableau to reason about Many-Valued Halpern and Shoham's modal logic of time intervals.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-multi-modal-tableau/#A-tableau-for-Many-Valued-Lutz-and-Wolter's-modal-logic-of-topological-relations-with-rectangular-areas-aligned-with-the-axes","page":"Many-Valued Multi-Modal Tableau","title":"A tableau for Many-Valued Lutz and Wolter's modal logic of topological   relations with rectangular areas aligned with the axes","text":"","category":"section"},{"location":"many-valued-multi-modal-tableau/","page":"Many-Valued Multi-Modal Tableau","title":"Many-Valued Multi-Modal Tableau","text":"MVLRCC8Tableau","category":"page"},{"location":"many-valued-multi-modal-tableau/#SoleReasoners.MVLRCC8Tableau","page":"Many-Valued Multi-Modal Tableau","title":"SoleReasoners.MVLRCC8Tableau","text":"Tableau to reason about Many-Valued Lutz and Wolter's modal logic of topological relations with rectangular areas aligned with the axes.\n\n\n\n\n\n","category":"type"}]
}
