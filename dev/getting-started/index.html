<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · SoleReasoners.jl</title><meta name="title" content="Getting started · SoleReasoners.jl"/><meta property="og:title" content="Getting started · SoleReasoners.jl"/><meta property="twitter:title" content="Getting started · SoleReasoners.jl"/><meta name="description" content="Documentation for SoleReasoners.jl."/><meta property="og:description" content="Documentation for SoleReasoners.jl."/><meta property="twitter:description" content="Documentation for SoleReasoners.jl."/><meta property="og:url" content="https://aclai-lab.github.io/SoleReasoners.jl/getting-started/"/><meta property="twitter:url" content="https://aclai-lab.github.io/SoleReasoners.jl/getting-started/"/><link rel="canonical" href="https://aclai-lab.github.io/SoleReasoners.jl/getting-started/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SoleReasoners.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#SAT-solver"><span>SAT solver</span></a></li><li><a class="tocitem" href="#Automated-theorem-prover"><span>Automated theorem prover</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleReasoners.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aclai-lab/SoleReasoners.jl/blob/main/docs/src/getting-started.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#man-core">Getting started</a></li><li class="no-marker"><ul><li><a href="#SAT-solver">SAT solver</a></li><li><a href="#Automated-theorem-prover">Automated theorem prover</a></li></ul></li></ul><h1 id="man-core"><a class="docs-heading-anchor" href="#man-core">Getting started</a><a id="man-core-1"></a><a class="docs-heading-anchor-permalink" href="#man-core" title="Permalink"></a></h1><p><em>SoleReasoners</em> mainly provides two tools for reasoning: <em>sat</em>, which aims at solving the <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">boolean satisfiability problem</a>, and <em>prove</em>, which serves as an <a href="https://en.wikipedia.org/wiki/Automated_theorem_proving">automated theorem prover</a> for propositional boolean formulae. Both algorithms are based on the <a href="https://en.wikipedia.org/wiki/Method_of_analytic_tableaux">method of analytic tableaux</a>.</p><p><em>SoleReasoners</em> also provides a suite for managing the tableau expansion policy, allowing for different configurations based on the specific application problem. This system is based on min-heaps concurring to provide candidates for the extraction based on user specified policies, and an agreement function to choose amongst such proposals.</p><p>For more information about the data structures involved, please refer to the developer documentation.</p><h2 id="SAT-solver"><a class="docs-heading-anchor" href="#SAT-solver">SAT solver</a><a id="SAT-solver-1"></a><a class="docs-heading-anchor-permalink" href="#SAT-solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleReasoners.sat-Union{Tuple{F}, Tuple{SoleLogics.Formula, F, Vararg{Function}}} where F&lt;:Function" href="#SoleReasoners.sat-Union{Tuple{F}, Tuple{SoleLogics.Formula, F, Vararg{Function}}} where F&lt;:Function"><code>SoleReasoners.sat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sat(formula::Formula, choosenode::Function, metrics::Function...)</code></pre><p>Given a formula, return true if an interpretation that satisfies the formula exists, false otherwise.</p><p><em>choosenode</em> should be a function taking a vector of metricheaps as an argument (and eventually a counter) and giving a tableau (or nothing) as output that is used to extract a node representing a branch to be expanded. If nothing, all branches are closed.</p><p><em>metrics</em> should be functions taking a tableau as an argument and giving an integer as output that are used to model the order in which tableau branches are  xpanded. For example, one could declare the following metric functions:</p><pre><code class="nohighlight hljs">mf1(t::Tableau) = noperators(t.formula)
mf2(t::Tableau) = height(t.formula)</code></pre><p>The first metric will generate a metricheap proposing to expand first branches comprising the node containing the formula with the less number of operators, the second metric will generate a metricheap proposing to expand first branches comprising the node containing the formula of less height.</p><p><em>choosenode</em> will then be used to choose which policy to follow (e.g., choosing the node voted by most heaps, or alternating between each heap at each cycle).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleReasoners.jl/blob/9a15a3f9d117be13239891d73e95bd86803c16a8/src/propositional-tableau/propositional-tableau.jl#L208-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleReasoners.sat-Union{Tuple{F}, Tuple{SoleLogics.Formula, F}} where F&lt;:Function" href="#SoleReasoners.sat-Union{Tuple{F}, Tuple{SoleLogics.Formula, F}} where F&lt;:Function"><code>SoleReasoners.sat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sat(
    formula::Formula,
    metric::F;
    rng = Random.GLOBAL_RNG
) where {
    F&lt;:Function
}</code></pre><p>Given a formula and an extraction policy metric, return true if an interpretation that satisfies the formula exists, false otherwise.</p><p><em>metric</em> should be a function taking a tableau as an argument and giving an integer as output that is used to model the order in which tableau branches are expanded. For example, one could declare the following metric function:</p><pre><code class="nohighlight hljs">mf(t::Tableau) = noperators(t.formula)</code></pre><p>This way, the tableau will be expanded giving precedence to branches comprising nodes containing formulae with the smallest number operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleReasoners.jl/blob/9a15a3f9d117be13239891d73e95bd86803c16a8/src/propositional-tableau/propositional-tableau.jl#L252-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleReasoners.sat-Tuple{SoleLogics.Formula}" href="#SoleReasoners.sat-Tuple{SoleLogics.Formula}"><code>SoleReasoners.sat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sat(formula::Formula; rng = Random.GLOBAL_RNG)</code></pre><p>Given a formula, return true if an interpretation that satisfies the formula exists, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleReasoners.jl/blob/9a15a3f9d117be13239891d73e95bd86803c16a8/src/propositional-tableau/propositional-tableau.jl#L277-L282">source</a></section></article><h2 id="Automated-theorem-prover"><a class="docs-heading-anchor" href="#Automated-theorem-prover">Automated theorem prover</a><a id="Automated-theorem-prover-1"></a><a class="docs-heading-anchor-permalink" href="#Automated-theorem-prover" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleReasoners.prove-Union{Tuple{F}, Tuple{SoleLogics.Formula, F, Vararg{Function}}} where F&lt;:Function" href="#SoleReasoners.prove-Union{Tuple{F}, Tuple{SoleLogics.Formula, F, Vararg{Function}}} where F&lt;:Function"><code>SoleReasoners.prove</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sat(formula::Formula, choosenode::Function, metrics::Function...)</code></pre><p>Given a formula, return true if it is valid, i.e., there is not an interpretation that does not satisfy the formula, false otherwise.</p><p><em>choosenode</em> should be a function taking a vector of metricheaps as an argument (and eventually a counter) and giving a tableau (or nothing) as output that is used to extract a node representing a branch to be expanded. If nothing, all branches are closed.</p><p><em>metrics</em> should be functions taking a tableau as an argument and giving an integer as output that are used to model the order in which tableau branches are expanded. For example, one could declare the following metric functions:</p><pre><code class="nohighlight hljs">mf1(t::Tableau) = noperators(t.formula)
mf2(t::Tableau) = height(t.formula)</code></pre><p>The first metric will generate a metricheap proposing to expand first branches comprising the node containing the formula with the less number of operators, the second metric will generate a metricheap proposing to expand first branches  omprising the node containing the formula of less height.</p><p><em>choosenode</em> will then be used to choose which policy to follow (e.g., choosing the node voted by most heaps, or alternating between each heap at each cycle).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleReasoners.jl/blob/9a15a3f9d117be13239891d73e95bd86803c16a8/src/propositional-tableau/propositional-tableau.jl#L288-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleReasoners.prove-Union{Tuple{F}, Tuple{SoleLogics.Formula, F}} where F&lt;:Function" href="#SoleReasoners.prove-Union{Tuple{F}, Tuple{SoleLogics.Formula, F}} where F&lt;:Function"><code>SoleReasoners.prove</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prove(formula::Formula, metric::F; kwargs...) where {F&lt;:Function}</code></pre><p>Given a formula, return true if it is valid, i.e., there is not an interpretation that does not satisfy the formula, false otherwise.</p><p><em>metric</em> should be a function taking a tableau as an argument and giving an integer as output that is used to model the order in which tableau branches are expanded. For example, one could declare the following metric function:</p><pre><code class="nohighlight hljs">mf(t::Tableau) = noperators(t.formula)</code></pre><p>This way, the tableau will be expanded giving precedence to branches comprising nodes containing formulae with the smallest number operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleReasoners.jl/blob/9a15a3f9d117be13239891d73e95bd86803c16a8/src/propositional-tableau/propositional-tableau.jl#L332-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoleReasoners.prove-Tuple{SoleLogics.Formula}" href="#SoleReasoners.prove-Tuple{SoleLogics.Formula}"><code>SoleReasoners.prove</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prove(formula::Formula; rng = Random.GLOBAL_RNG)</code></pre><p>Given a formula, return true if it is valid, i.e., there is not an interpretation that does not satisfy the formula, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aclai-lab/SoleReasoners.jl/blob/9a15a3f9d117be13239891d73e95bd86803c16a8/src/propositional-tableau/propositional-tableau.jl#L352-L357">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 11 September 2025 08:08">Thursday 11 September 2025</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
