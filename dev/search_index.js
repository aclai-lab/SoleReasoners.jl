var documenterSearchIndex = {"docs":
[{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Pages = [\"getting-started.md\"]","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleReasoners mainly provides two tools for reasoning: sat, which aims at solving the boolean satisfiability problem, and prove, which serves as an automated theorem prover for propositional boolean formulae. Both algorithms are based on the method of analytic tableaux.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleReasoners also provides a suite for managing the tableau expansion policy, allowing for different configurations based on the specific application problem. This system is based on min-heaps concurring to provide candidates for the extraction based on user specified policies, and an agreement function to choose amongst such proposals.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For more information about the data structures involved, please refer to the developer documentation.","category":"page"},{"location":"getting-started/#SAT-solver","page":"Getting started","title":"SAT solver","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"sat(formula::Formula, chooseleaf::F, metrics::Function...) where {F<:Function}\nsat(formula::Formula, metric::F; kwargs...) where {F<:Function}\nsat(formula::Formula; rng = Random.GLOBAL_RNG, kwargs...)","category":"page"},{"location":"getting-started/#SoleReasoners.sat-Union{Tuple{F}, Tuple{Formula, F, Vararg{Function}}} where F<:Function","page":"Getting started","title":"SoleReasoners.sat","text":"sat(formula::Formula, choosenode::Function, metrics::Function...)\n\nGiven a formula, return true if an interpretation that satisfies the formula exists, false otherwise.\n\nchoosenode should be a function taking a vector of metricheaps as an argument (and eventually a counter) and giving a tableau (or nothing) as output that is used to extract a node representing a branch to be expanded. If nothing, all branches are closed.\n\nmetrics should be functions taking a tableau as an argument and giving an integer as output that are used to model the order in which tableau branches are expanded. For example, one could declare the following metric functions:\n\nmf1(t::Tableau) = noperators(t.formula)\nmf2(t::Tableau) = height(t.formula)\n\nThe first metric will generate a metricheap proposing to expand first branches comprising the node containing the formula with the less number of operators, the second metric will generate a metricheap proposing to expand first branches comprising the node containing the formula of less height.\n\nchoosenode will then be used to choose which policy to follow (e.g., choosing the node voted by most heaps, or alternating between each heap at each cycle).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleReasoners.sat-Union{Tuple{F}, Tuple{Formula, F}} where F<:Function","page":"Getting started","title":"SoleReasoners.sat","text":"sat(formula::Formula, metric::F; rng = Random.GLOBAL_RNG) where {F<:Function}\n\nGiven a formula and an extraction policy metric, return true if an interpretation that satisfies the formula exists, false otherwise.\n\nmetric should be a function taking a tableau as an argument and giving an integer as output that is used to model the order in which tableau branches are expanded. For example, one could declare the following metric function:\n\nmf(t::Tableau) = noperators(t.formula)\n\nThis way, the tableau will be expanded giving precedence to branches comprising nodes containing formulae with the smallest number operators.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleReasoners.sat-Tuple{Formula}","page":"Getting started","title":"SoleReasoners.sat","text":"sat(formula::Formula; rng = Random.GLOBAL_RNG)\n\nGiven a formula, return true if an interpretation that satisfies the formula exists, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Automated-theorem-prover","page":"Getting started","title":"Automated theorem prover","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"prove(formula::Formula, chooseleaf::F, metrics::Function...) where {F<:Function}\nprove(formula::Formula, metric::F; kwargs...) where {F<:Function}\nprove(formula::Formula; rng = Random.GLOBAL_RNG, kwargs...)","category":"page"},{"location":"getting-started/#SoleReasoners.prove-Union{Tuple{F}, Tuple{Formula, F, Vararg{Function}}} where F<:Function","page":"Getting started","title":"SoleReasoners.prove","text":"sat(formula::Formula, choosenode::Function, metrics::Function...)\n\nGiven a formula, return true if it is valid, i.e., there is not an interpretation that does not satisfy the formula, false otherwise.\n\nchoosenode should be a function taking a vector of metricheaps as an argument (and eventually a counter) and giving a tableau (or nothing) as output that is used to extract a node representing a branch to be expanded. If nothing, all branches are closed.\n\nmetrics should be functions taking a tableau as an argument and giving an integer as output that are used to model the order in which tableau branches are expanded. For example, one could declare the following metric functions:\n\nmf1(t::Tableau) = noperators(t.formula)\nmf2(t::Tableau) = height(t.formula)\n\nThe first metric will generate a metricheap proposing to expand first branches comprising the node containing the formula with the less number of operators, the second metric will generate a metricheap proposing to expand first branches comprising the node containing the formula of less height.\n\nchoosenode will then be used to choose which policy to follow (e.g., choosing the node voted by most heaps, or alternating between each heap at each cycle).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleReasoners.prove-Union{Tuple{F}, Tuple{Formula, F}} where F<:Function","page":"Getting started","title":"SoleReasoners.prove","text":"prove(formula::Formula, metric::F; kwargs...) where {F<:Function}\n\nGiven a formula, return true if it is valid, i.e., there is not an interpretation that does not satisfy the formula, false otherwise.\n\nmetric should be a function taking a tableau as an argument and giving an integer as output that is used to model the order in which tableau branches are expanded. For example, one could declare the following metric function:\n\nmf(t::Tableau) = noperators(t.formula)\n\nThis way, the tableau will be expanded giving precedence to branches comprising nodes containing formulae with the smallest number operators.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleReasoners.prove-Tuple{Formula}","page":"Getting started","title":"SoleReasoners.prove","text":"prove(formula::Formula; rng = Random.GLOBAL_RNG)\n\nGiven a formula, return true if it is valid, i.e., there is not an interpretation that does not satisfy the formula, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"developer-documentation/","page":"Developer documentation","title":"Developer documentation","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"developer-documentation/","page":"Developer documentation","title":"Developer documentation","text":"Pages = [\"developer-documentation.md\"]","category":"page"},{"location":"developer-documentation/#man-core","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"developer-documentation/#Tableau","page":"Developer documentation","title":"Tableau","text":"","category":"section"},{"location":"developer-documentation/","page":"Developer documentation","title":"Developer documentation","text":"AbstractTableau\nTableau\nManyValuedTableau","category":"page"},{"location":"developer-documentation/#SoleReasoners.AbstractTableau","page":"Developer documentation","title":"SoleReasoners.AbstractTableau","text":"abstract type AbstractTableau end\n\nAbstract type for all tableaux structures.\n\nAn analytic tableau is a tree structure computed for a logical formula having at each node a subformula of the original formula to be proved or refuted. It is used in many automated reasoning tasks, such as automated theorem proving and the satifiability problem.\n\n\n\n\n\n","category":"type"},{"location":"developer-documentation/#SoleReasoners.Tableau","page":"Developer documentation","title":"SoleReasoners.Tableau","text":"mutable struct Tableau <: AbstractTableau\n    const formula::Formula\n    const father::Union{Tableau, Nothing}\n    children::Vector{Tableau}\n    expanded::Bool\n    closed::Bool\nend\n\nA mutable structure representing a tableau as a tree structure, with each node containing a subformula of the original formula, the father and children in the tree structure, a flag saying if the node has already been expanded and a flag saying if the branch represented by the node has been closed. Each path from a leaf to the root respresents a branch.\n\n\n\n\n\n","category":"type"},{"location":"developer-documentation/#SoleReasoners.ManyValuedTableau","page":"Developer documentation","title":"SoleReasoners.ManyValuedTableau","text":"mutable struct ManyValuedTableau{T<:Truth} <: AbstractTableau\n    const signedformula::SignedFormula{T}\n    const father::Union{ManyValuedTableau{T}, Nothing}\n    children::Vector{ManyValuedTableau{T}}\n    expanded::Bool\n    closed::Bool\nend\n\nA mutable structure representing a tableau as a tree structure, with each node containing a signed formula, the father and children in the tree structure, a flag saying if the node has already been expanded and a flag saying if the branch represented by the node has been closed. Each path from a leaf to the root respresents a branch.\n\n\n\n\n\n","category":"type"},{"location":"developer-documentation/#SignedFormula","page":"Developer documentation","title":"SignedFormula","text":"","category":"section"},{"location":"developer-documentation/","page":"Developer documentation","title":"Developer documentation","text":"SignedFormula","category":"page"},{"location":"developer-documentation/#SoleReasoners.SignedFormula","page":"Developer documentation","title":"SoleReasoners.SignedFormula","text":"struct SignedFormula{T<:Truth}\n    sign::Bool\n    boundingimplication::Union{Tuple{T, Formula}, Tuple{Formula, T}, Tuple{T, T}}\nend\n\nAll formulas appearing in the many-valued tableau will be bounding implications, i.e., a → A (or A → a), where a is a propositional constant and asserting a ≤ A (resp. A ≤ a).\n\n\n\n\n\n","category":"type"},{"location":"developer-documentation/#MetrichHeap","page":"Developer documentation","title":"MetrichHeap","text":"","category":"section"},{"location":"developer-documentation/","page":"Developer documentation","title":"Developer documentation","text":"MetricHeapNode\nMetricHeap","category":"page"},{"location":"developer-documentation/#SoleReasoners.MetricHeapNode","page":"Developer documentation","title":"SoleReasoners.MetricHeapNode","text":"struct MetricHeapNode{T<:AbstractTableau}\n    metricvalue::Int\n    tableau::T\nend\n\nThe atomic element of a MetricHeap, it contains a tableau branch and a value for the metric associated with the MetricHeap it is contained in.\n\n\n\n\n\n","category":"type"},{"location":"developer-documentation/#SoleReasoners.MetricHeap","page":"Developer documentation","title":"SoleReasoners.MetricHeap","text":"struct MetricHeap\n    heap::BinaryHeap{MetricHeapNode}\n    metric::Function\nend\n\nA MetricHeap is basically a heap parametrized over a metric, i.e., a function which extracts some information about a tableau branch, therefore containing in each node a tableau branch and the relative value for the metric, and which is ordered as a min heap over this metric value.\n\n\n\n\n\n","category":"type"},{"location":"many-valued-logics/","page":"Many-Valued logics","title":"Many-Valued logics","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"many-valued-logics/","page":"Many-Valued logics","title":"Many-Valued logics","text":"Pages = [\"many-valued-logics.md\"]","category":"page"},{"location":"many-valued-logics/#man-core","page":"Many-Valued logics","title":"Many-Valued logics","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-Valued logics","title":"Many-Valued logics","text":"In addition to sat and prove, SoleReasoners also provides methods to deal with their many-valued couterparts, respectively alphasat and alphaprove. The former aims at solving the alpha-satisfiability problem, i.e., if there exists a model such that a given many-valued formula assumes value of at least alpha, while the latter aims at solving the alpha-validity problem, i.e., if there is not a model for which a given many-valued formula does not assume value of at least alpha.","category":"page"},{"location":"many-valued-logics/","page":"Many-Valued logics","title":"Many-Valued logics","text":"For more information about the data structures involved, please refer to the developer documentation.","category":"page"},{"location":"many-valued-logics/#(\\alpha-)SAT-solver","page":"Many-Valued logics","title":"(alpha-)SAT solver","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-Valued logics","title":"Many-Valued logics","text":"sat(\n    z::Formula,\n    h::A;\n    rng = Random.GLOBAL_RNG,\n    verbose::Bool=false,\n    timeout::Union{Nothing,Int}=nothing,\n    kwargs...\n) where {\n    T<:Truth,\n    D<:AbstractVector{T},\n    A<:FiniteAlgebra{T,D}\n}\nalphasat(\n        α::T1,\n        z::Formula,\n        a::A;\n        rng = Random.GLOBAL_RNG,\n        verbose::Bool=false,\n        timeout::Union{Nothing,Int}=nothing,\n        kwargs...\n    ) where {\n        T<:Truth,\n        D<:AbstractVector{T},\n        A<:FiniteAlgebra{T,D},\n        T1<:Truth\n    }","category":"page"},{"location":"many-valued-logics/#SoleReasoners.sat-Union{Tuple{A}, Tuple{D}, Tuple{T}, Tuple{Formula, A}} where {T<:Truth, D<:AbstractVector{T}, A<:SoleLogics.ManyValuedLogics.FiniteAlgebra{T, D}}","page":"Many-Valued logics","title":"SoleReasoners.sat","text":"sat(\n    z::Formula,\n    h::A;\n    rng = Random.GLOBAL_RNG,\n    verbose::Bool=false,\n    timeout::Union{Nothing,Int}=nothing,\n    kwargs...\n) where {\n    T<:Truth,\n    D<:AbstractVector{T},\n    A<:FiniteAlgebra{T,D}\n}\n\nGiven a formula, return true if an interpretation that satisfies the formula exists, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-logics/#SoleReasoners.alphasat-Union{Tuple{T1}, Tuple{A}, Tuple{D}, Tuple{T}, Tuple{T1, Formula, A}} where {T<:Truth, D<:AbstractVector{T}, A<:SoleLogics.ManyValuedLogics.FiniteAlgebra{T, D}, T1<:Truth}","page":"Many-Valued logics","title":"SoleReasoners.alphasat","text":"alphasat(\n    α::T1,\n    z::Formula,\n    a::A;\n    rng = Random.GLOBAL_RNG,\n    verbose::Bool=false,\n    timeout::Union{Nothing,Int}=nothing,\n    kwargs...\n) where {\n    T<:Truth,\n    D<:AbstractVector{T},\n    A<:FiniteAlgebra{T,D},\n    T1<:Truth\n}\n\nGiven a formula, return true if it is α-satisfiable, i.e., there is an interpretation such that the formula assumes value of at least α, nothing in case of timeout or out-of-memory error, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-logics/#Automated-theorem-(\\alpha-)prover","page":"Many-Valued logics","title":"Automated theorem (alpha-)prover","text":"","category":"section"},{"location":"many-valued-logics/","page":"Many-Valued logics","title":"Many-Valued logics","text":"prove(\n        z::Formula,\n        h::A;\n        rng = Random.GLOBAL_RNG,\n        verbose::Bool=false,\n        timeout::Union{Nothing,Int}=nothing,\n        kwargs...\n    ) where {\n        T<:Truth,\n        D<:AbstractVector{T},\n        A<:FiniteAlgebra{T,D}\n    }\nalphaprove(\n        α::T1,\n        z::Formula,\n        a::A;\n        rng = Random.GLOBAL_RNG,\n        verbose::Bool=false,\n        timeout::Union{Nothing,Int}=nothing,\n        kwargs...\n    ) where {\n        T<:Truth,\n        D<:AbstractVector{T},\n        A<:FiniteAlgebra{T,D},\n        T1<:Truth\n    }","category":"page"},{"location":"many-valued-logics/#SoleReasoners.prove-Union{Tuple{A}, Tuple{D}, Tuple{T}, Tuple{Formula, A}} where {T<:Truth, D<:AbstractVector{T}, A<:SoleLogics.ManyValuedLogics.FiniteAlgebra{T, D}}","page":"Many-Valued logics","title":"SoleReasoners.prove","text":"prove(\n    z::Formula,\n    h::A;\n    rng = Random.GLOBAL_RNG,\n    verbose::Bool=false,\n    timeout::Union{Nothing,Int}=nothing,\n    kwargs...\n) where {\n    T<:Truth,\n    D<:AbstractVector{T},\n    A<:FiniteAlgebra{T,D}\n}\n\nGiven a formula, return true if it is valid, i.e., there is not an interpretation that does not satisfy the formula, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"many-valued-logics/#SoleReasoners.alphaprove-Union{Tuple{T1}, Tuple{A}, Tuple{D}, Tuple{T}, Tuple{T1, Formula, A}} where {T<:Truth, D<:AbstractVector{T}, A<:SoleLogics.ManyValuedLogics.FiniteAlgebra{T, D}, T1<:Truth}","page":"Many-Valued logics","title":"SoleReasoners.alphaprove","text":"alphaprove()\n    α::T1,\n    z::Formula,\n    a::A;\n    rng = Random.GLOBAL_RNG,\n    verbose::Bool=false,\n    timeout::Union{Nothing,Int}=nothing,\n    kwargs...\n) where {\n    T<:Truth,\n    D<:AbstractVector{T},\n    A<:FiniteAlgebra{T,D},\n    T1<:Truth\n}\n\nGiven a formula, return true if it is α-valid, i.e., there is not an interpretation such that the formula does not assume value of at least α, nothing in case of timeout or out-of-memory error, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"#SoleReasoners","page":"Home","title":"SoleReasoners","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleReasoners, a Julia package for automated reasoning built on top of SoleLogics and part of Sole.jl, an open-source framework for symbolic machine learning.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SoleReasoners.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SoleReasoners\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleReasoners.jl provides a sat solver and an automated theorem prover based on the method of analytic tableau. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It also provides a Many-Valued version for both algorithms, therefore solving the alpha-satisfiability and alpha-validity problems respectively.","category":"page"},{"location":"#Future-work","page":"Home","title":"Future work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We are currently working on a Modal version of both algorithms which also works with Many-Valued logics.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"#More-on-Sole","page":"Home","title":"More on Sole","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleLogics\nSoleData.jl\nSoleFeatures.jl \nSoleModels.jl\nSolePostHoc.jl","category":"page"}]
}
