var documenterSearchIndex = {"docs":
[{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Pages = [\"getting-started.md\"]","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleReasoners mainly provides two tools for reasoning: sat, which aims at solving the boolean satisfiability problem, and prove, which serves as an automated theorem prover for propositional boolean formulae. Both algorithms are based on the method of analytic tableaux.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleReasoners also provides a suite for managing the tableau expansion policy, allowing for different configurations based on the specific application problem. This system is based on min-heaps concurring to provide candidates for the extraction based on user specified policies, and an agreement function to choose amongst such proposals.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For more information about the data structures involved, please refer to the developer documentation.","category":"page"},{"location":"getting-started/#SAT-solver","page":"Getting started","title":"SAT solver","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"sat(formula::Formula, chooseleaf::F, metrics::Function...) where {F<:Function}\nsat(formula::Formula, metric::F; kwargs...) where {F<:Function}\nsat(formula::Formula; rng = Random.GLOBAL_RNG, kwargs...)","category":"page"},{"location":"getting-started/#SoleReasoners.sat-Union{Tuple{F}, Tuple{SoleLogics.Formula, F, Vararg{Function}}} where F<:Function","page":"Getting started","title":"SoleReasoners.sat","text":"sat(formula::Formula, choosenode::Function, metrics::Function...)\n\nGiven a formula, return true if an interpretation that satisfies the formula exists, false otherwise.\n\nchoosenode should be a function taking a vector of metricheaps as an argument (and eventually a counter) and giving a tableau (or nothing) as output that is used to extract a node representing a branch to be expanded. If nothing, all branches are closed.\n\nmetrics should be functions taking a tableau as an argument and giving an integer as output that are used to model the order in which tableau branches are  xpanded. For example, one could declare the following metric functions:\n\nmf1(t::Tableau) = noperators(t.formula)\nmf2(t::Tableau) = height(t.formula)\n\nThe first metric will generate a metricheap proposing to expand first branches comprising the node containing the formula with the less number of operators, the second metric will generate a metricheap proposing to expand first branches comprising the node containing the formula of less height.\n\nchoosenode will then be used to choose which policy to follow (e.g., choosing the node voted by most heaps, or alternating between each heap at each cycle).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleReasoners.sat-Union{Tuple{F}, Tuple{SoleLogics.Formula, F}} where F<:Function","page":"Getting started","title":"SoleReasoners.sat","text":"sat(\n    formula::Formula,\n    metric::F;\n    rng = Random.GLOBAL_RNG\n) where {\n    F<:Function\n}\n\nGiven a formula and an extraction policy metric, return true if an interpretation that satisfies the formula exists, false otherwise.\n\nmetric should be a function taking a tableau as an argument and giving an integer as output that is used to model the order in which tableau branches are expanded. For example, one could declare the following metric function:\n\nmf(t::Tableau) = noperators(t.formula)\n\nThis way, the tableau will be expanded giving precedence to branches comprising nodes containing formulae with the smallest number operators.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleReasoners.sat-Tuple{SoleLogics.Formula}","page":"Getting started","title":"SoleReasoners.sat","text":"sat(formula::Formula; rng = Random.GLOBAL_RNG)\n\nGiven a formula, return true if an interpretation that satisfies the formula exists, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Automated-theorem-prover","page":"Getting started","title":"Automated theorem prover","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"prove(formula::Formula, chooseleaf::F, metrics::Function...) where {F<:Function}\nprove(formula::Formula, metric::F; kwargs...) where {F<:Function}\nprove(formula::Formula; rng = Random.GLOBAL_RNG, kwargs...)","category":"page"},{"location":"getting-started/#SoleReasoners.prove-Union{Tuple{F}, Tuple{SoleLogics.Formula, F, Vararg{Function}}} where F<:Function","page":"Getting started","title":"SoleReasoners.prove","text":"sat(formula::Formula, choosenode::Function, metrics::Function...)\n\nGiven a formula, return true if it is valid, i.e., there is not an interpretation that does not satisfy the formula, false otherwise.\n\nchoosenode should be a function taking a vector of metricheaps as an argument (and eventually a counter) and giving a tableau (or nothing) as output that is used to extract a node representing a branch to be expanded. If nothing, all branches are closed.\n\nmetrics should be functions taking a tableau as an argument and giving an integer as output that are used to model the order in which tableau branches are expanded. For example, one could declare the following metric functions:\n\nmf1(t::Tableau) = noperators(t.formula)\nmf2(t::Tableau) = height(t.formula)\n\nThe first metric will generate a metricheap proposing to expand first branches comprising the node containing the formula with the less number of operators, the second metric will generate a metricheap proposing to expand first branches  omprising the node containing the formula of less height.\n\nchoosenode will then be used to choose which policy to follow (e.g., choosing the node voted by most heaps, or alternating between each heap at each cycle).\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleReasoners.prove-Union{Tuple{F}, Tuple{SoleLogics.Formula, F}} where F<:Function","page":"Getting started","title":"SoleReasoners.prove","text":"prove(formula::Formula, metric::F; kwargs...) where {F<:Function}\n\nGiven a formula, return true if it is valid, i.e., there is not an interpretation that does not satisfy the formula, false otherwise.\n\nmetric should be a function taking a tableau as an argument and giving an integer as output that is used to model the order in which tableau branches are expanded. For example, one could declare the following metric function:\n\nmf(t::Tableau) = noperators(t.formula)\n\nThis way, the tableau will be expanded giving precedence to branches comprising nodes containing formulae with the smallest number operators.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#SoleReasoners.prove-Tuple{SoleLogics.Formula}","page":"Getting started","title":"SoleReasoners.prove","text":"prove(formula::Formula; rng = Random.GLOBAL_RNG)\n\nGiven a formula, return true if it is valid, i.e., there is not an interpretation that does not satisfy the formula, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"developer-documentation/","page":"-","title":"-","text":"<!– ```@meta CurrentModule = SoleReasoners","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"@contents Pages = [\"developer-documentation.md\"]","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"\n# [Developer documentation](@id man-core)\n\n## Tableau\n","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"@docs AbstractTableau Tableau ManyValuedTableau","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"\n### SignedFormula\n","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"@docs SignedFormula","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"\n## MetrichHeap\n","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"@docs MetricHeapNode MetricHeap ``` –>","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"<!– ```@meta CurrentModule = SoleReasoners","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"@contents Pages = [\"many-valued-logics.md\"]","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"\n# [Many-Valued logics](@id man-core)\n\nIn addition to *sat* and *prove*, *SoleReasoners* also provides methods to deal with their many-valued couterparts, respectively *alphasat* and *alphaprove*. The former aims at solving the $\\alpha$-satisfiability problem, i.e., if there exists a model such that a given many-valued formula assumes value of at least $\\alpha$, while the latter aims at solving the $\\alpha$-validity problem, i.e., if there is not a model for which a given many-valued formula does not assume value of at least $\\alpha$.\n\nFor more information about the data structures involved, please refer to the developer documentation.\n\n## ($\\alpha$-)SAT solver\n","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"@docs sat(     z::Formula,     h::A;     rng = Random.GLOBALRNG,     verbose::Bool=false,     timeout::Union{Nothing,Int}=nothing,     kwargs... ) where {     T<:Truth,     D<:AbstractVector{T},     A<:FiniteAlgebra{T,D} } alphasat(         α::T1,         z::Formula,         a::A;         rng = Random.GLOBALRNG,         verbose::Bool=false,         timeout::Union{Nothing,Int}=nothing,         kwargs...     ) where {         T<:Truth,         D<:AbstractVector{T},         A<:FiniteAlgebra{T,D},         T1<:Truth     }","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"\n## Automated theorem ($\\alpha$-)prover","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"@docs prove(         z::Formula,         h::A;         rng = Random.GLOBALRNG,         verbose::Bool=false,         timeout::Union{Nothing,Int}=nothing,         kwargs...     ) where {         T<:Truth,         D<:AbstractVector{T},         A<:FiniteAlgebra{T,D}     } alphaprove(         α::T1,         z::Formula,         a::A;         rng = Random.GLOBALRNG,         verbose::Bool=false,         timeout::Union{Nothing,Int}=nothing,         kwargs...     ) where {         T<:Truth,         D<:AbstractVector{T},         A<:FiniteAlgebra{T,D},         T1<:Truth     } ``` –>","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"#SoleReasoners","page":"Home","title":"SoleReasoners","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleReasoners, a Julia package for automated reasoning built on top of SoleLogics and part of Sole.jl, an open-source framework for symbolic machine learning.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SoleReasoners.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SoleReasoners\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleReasoners.jl provides a sat solver and an automated theorem prover based on the method of analytic tableau. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It also provides a Many-Valued version for both algorithms, therefore solving the alpha-satisfiability and alpha-validity problems respectively.","category":"page"},{"location":"#Future-work","page":"Home","title":"Future work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We are currently working on a Modal version of both algorithms which also works with Many-Valued logics.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"#More-on-Sole","page":"Home","title":"More on Sole","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleLogics\nSoleData.jl\nSoleFeatures.jl \nSoleModels.jl\nSolePostHoc.jl","category":"page"}]
}
