var documenterSearchIndex = {"docs":
[{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Pages = [\"getting-started.md\"]","category":"page"},{"location":"getting-started/#man-core","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleReasoners mainly provides two tools for reasoning: sat, which aims at solving the boolean satisfiability problem, and prove, which serves as an automated theorem prover for propositional boolean formulae. Both algorithms are based on the method of analytic tableaux.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"SoleReasoners also provides a suite for managing the tableau expansion policy, allowing for different configurations based on the specific application problem. This system is based on min-heaps concurring to provide candidates for the extraction based on user specified policies, and an agreement function to choose amongst such proposals.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For more information about the data structures involved, please refer to the developer documentation.","category":"page"},{"location":"getting-started/#SAT-solver","page":"Getting started","title":"SAT solver","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"sat(formula::Formula, chooseleaf::F, metrics::Function...) where {F<:Function}\nsat(formula::Formula, metric::F; kwargs...) where {F<:Function}\nsat(formula::Formula; rng = Random.GLOBAL_RNG, kwargs...)","category":"page"},{"location":"getting-started/#Automated-theorem-prover","page":"Getting started","title":"Automated theorem prover","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"prove(formula::Formula, chooseleaf::F, metrics::Function...) where {F<:Function}\nprove(formula::Formula, metric::F; kwargs...) where {F<:Function}\nprove(formula::Formula; rng = Random.GLOBAL_RNG, kwargs...)","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"<!– ```@meta CurrentModule = SoleReasoners","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"@contents Pages = [\"developer-documentation.md\"]","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"\n# [Developer documentation](@id man-core)\n\n## Tableau\n","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"@docs AbstractTableau Tableau ManyValuedTableau","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"\n### SignedFormula\n","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"@docs SignedFormula","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"\n## MetrichHeap\n","category":"page"},{"location":"developer-documentation/","page":"-","title":"-","text":"@docs MetricHeapNode MetricHeap ``` –>","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"<!– ```@meta CurrentModule = SoleReasoners","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"@contents Pages = [\"many-valued-logics.md\"]","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"\n# [Many-Valued logics](@id man-core)\n\nIn addition to *sat* and *prove*, *SoleReasoners* also provides methods to deal with their many-valued couterparts, respectively *alphasat* and *alphaprove*. The former aims at solving the $\\alpha$-satisfiability problem, i.e., if there exists a model such that a given many-valued formula assumes value of at least $\\alpha$, while the latter aims at solving the $\\alpha$-validity problem, i.e., if there is not a model for which a given many-valued formula does not assume value of at least $\\alpha$.\n\nFor more information about the data structures involved, please refer to the developer documentation.\n\n## ($\\alpha$-)SAT solver\n","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"@docs sat(     z::Formula,     h::A;     rng = Random.GLOBALRNG,     verbose::Bool=false,     timeout::Union{Nothing,Int}=nothing,     kwargs... ) where {     T<:Truth,     D<:AbstractVector{T},     A<:FiniteAlgebra{T,D} } alphasat(         α::T1,         z::Formula,         a::A;         rng = Random.GLOBALRNG,         verbose::Bool=false,         timeout::Union{Nothing,Int}=nothing,         kwargs...     ) where {         T<:Truth,         D<:AbstractVector{T},         A<:FiniteAlgebra{T,D},         T1<:Truth     }","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"\n## Automated theorem ($\\alpha$-)prover","category":"page"},{"location":"many-valued-logics/","page":"-","title":"-","text":"@docs prove(         z::Formula,         h::A;         rng = Random.GLOBALRNG,         verbose::Bool=false,         timeout::Union{Nothing,Int}=nothing,         kwargs...     ) where {         T<:Truth,         D<:AbstractVector{T},         A<:FiniteAlgebra{T,D}     } alphaprove(         α::T1,         z::Formula,         a::A;         rng = Random.GLOBALRNG,         verbose::Bool=false,         timeout::Union{Nothing,Int}=nothing,         kwargs...     ) where {         T<:Truth,         D<:AbstractVector{T},         A<:FiniteAlgebra{T,D},         T1<:Truth     } ``` –>","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SoleReasoners","category":"page"},{"location":"#SoleReasoners","page":"Home","title":"SoleReasoners","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SoleReasoners, a Julia package for automated reasoning built on top of SoleLogics and part of Sole.jl, an open-source framework for symbolic machine learning.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SoleReasoners.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SoleReasoners\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleReasoners.jl provides a sat solver and an automated theorem prover based on the method of analytic tableau. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"It also provides a Many-Valued version for both algorithms, therefore solving the alpha-satisfiability and alpha-validity problems respectively.","category":"page"},{"location":"#Future-work","page":"Home","title":"Future work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We are currently working on a Modal version of both algorithms which also works with Many-Valued logics.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed by the ACLAI Lab @ University of Ferrara.","category":"page"},{"location":"#More-on-Sole","page":"Home","title":"More on Sole","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SoleLogics\nSoleData.jl\nSoleFeatures.jl \nSoleModels.jl\nSolePostHoc.jl","category":"page"}]
}
